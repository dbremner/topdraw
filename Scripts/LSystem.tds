
desktop.fillLayer(new Gradient(new Color(0.3), new Color(0.8)));

var ls = new LSystem();
var iterations = 10;
var db = desktop.bounds;
var circleRnd = new Randomizer(0.1, 3.0);
var circleScale = circleRnd.floatValue;

function FilledCircle(lsys) {
	var depth = lsys.depth;
	var size = lsys.length * circleScale;
	var radius = depth > 0 ? depth * size : size;
	var lastRule = lsys.lastRule;
	var lastTurn = lsys.lastTurn;
		
	if (lastRule != "Y")
		return;

	if (lastTurn == "+") {
		desktop.fillStyle = new Color("green", 0.5);
		radius *= 0.5;
	}	else {
		desktop.fillStyle = new Color("blue", 0.3);
	}

	desktop.beginPath();
	desktop.circle(0, 0, radius); 
	desktop.fill();
}

function Sierpinski() {
	ls.root = "A";
	ls.addRule("A", "B-A-B");
	ls.addRule("B", "A+B+A");
	ls.length = 9;
	ls.angle = 60;
	desktop.translate(1100, 50)
	desktop.rotate(Math.PI * (0 / 180));
	iterations = 7;
}

function DragonCurve() {
	ls.drawFunction = FilledCircle;
	ls.root = "FX";
	ls.addRule("X", "X+YF+");
	ls.addRule("Y", "-FX-Y");
	ls.length = 8;
	ls.angle = 90;
	iterations = 12;
	desktop.rotate(Math.PI * (90 / 180));
	desktop.translate(400, -1800)
}

// Draw the Sierpinski in yellow
desktop.strokeStyle = new Color("yellow");
desktop.save();
Sierpinski();
ls.drawInLayer(desktop, 0, 0, iterations);
desktop.restore();

// Draw the Dragon lines
desktop.strokeStyle = new Color("white");
desktop.save();
DragonCurve();
ls.drawFunction = undefined;
ls.drawInLayer(desktop, 0, 0, iterations);
desktop.restore();

// Now draw it with filled circles
desktop.save();
DragonCurve();
ls.drawInLayer(desktop, 0, 0, iterations);
desktop.restore();



